package require ag 0.3

set SRT_VERSION 1.3.0

lassign [split $SRT_VERSION .] SRT_VERSION_MAJOR SRT_VERSION_MINOR SRT_VERSION_PATCH

#set VERSION 1.3.0

# Choosing the toolchain profile is a little bit more complicated than just select one.
# There's a separate script for that, pushed there in order not to make so much noise.
source ag/ag-choose-toolchain-profile.tcl
ag-profile posix-install

# Experimental: Use a separate directory for intermediate files
#namespace eval agv::p {
#proc gen-imfile-mydir-path {target srcfile} {
#	file mkdir $::agv::builddir/im
#	return im/[gen-imfile-path $target $srcfile]
#}
#}
#ag-profile general -imgen mydir-path

# Ok, now variables

set srtstatic 0
set srtshared 0

if { [info exists WITH_LIBSPEC] } {
	if { [string first , $WITH_LIBSPEC] != -1 } {
		set WITH_LIBSPEC [split $WITH_LIBSPEC ,]
	}

	if { "shared" in $WITH_LIBSPEC } {
		set srtshared 1
	}

	if { "static" in $WITH_LIBSPEC } {
		set srtstatic 1
	}
} else {

	if { [phas ENABLE_SHARED] } {
		set srtshared 1
	}

	if { [phas ENABLE_STATIC] } {
		set srtstatic 1
	}
}

# Enable static and shared by default
# Disable shared only if ENABLE_STATIC
# Keep default shared enabled due to LGPL requirements.
# Keep also static enabled because it's required as a dependency of stransmit.

if { $srtshared == 0 && $srtstatic == 1 } {
	pset srt_libspec static
} else {
	pset srt_libspec static shared
}

puts "SRT LIBSPEC: $srt_libspec"

ag-profile {c c++} -D {SRT_VERSION=\"$SRT_VERSION\"}


# -- Selecting  debug/release version

# XXX This feature is not yet supported
# if { [ag-config option ?buildtype] == "debug" } {
# 	set SRT_DEBUG_ENABLED 1
# 	set SRT_DEBUG_OPT "-ggdb -O0"
# } else {
# 	set SRT_DEBUG_ENABLED 0
# 	set SRT_DEBUG_OPT "-O2 -DNDEBUG"
# }
# ag-profile {c c++} -cflags $SRT_DEBUG_OPT

# Old name
if { [phas DEBUG] } {
	set ENABLE_DEBUG $DEBUG
}

# CONSIDER:
# set BUILD_TYPE [ag-config option ?buildtype]
switch -- [pget ENABLE_DEBUG] {
	"" - 0 {
		set BUILD_TYPE release
	}

	1 {
		set BUILD_TYPE debug
	}

	2 {
		set BUILD_TYPE release-debug-info
	}
}

set foptimize [pis $BUILD_TYPE release* ? -O3 : -O0]
set fdebug [pis $BUILD_TYPE *debug* ? -g -D_DEBUG : -DNDEBUG]

puts "BUILD TYPE: $BUILD_TYPE  cflags: opt:$foptimize debug:$fdebug"

ag-profile {c c++} -cflags -- $foptimize $fdebug

# XXX EXPERIMENTAL for socket groups
ag-profile {c c++} -D SRT_ENABLE_APP_READER

# XXX Can be disabled, need to expose

ag-profile {c c++} -D SRT_ENABLE_PKTINFO

set ENABLE_HEAVY_LOGGING_DEFAULT [string match *debug* $BUILD_TYPE]

pinit ENABLE_LOGGING 1
pinit ENABLE_HEAVY_LOGGING $ENABLE_HEAVY_LOGGING_DEFAULT
pinit ENABLE_ENCRYPTION 1


# -- Selecting profiled version

if { [phas env(HAI_BUILD_PROFILE)] } {
	puts "+++ Build will include PROFILE INFORMATION"
	set SRT_BUILD_PROFILE 1
} else {
	set SRT_BUILD_PROFILE 0
}

# -- C/C++ header dependency file handling flavor
ag-profile general -depspec cached -dumpinfo on

# -- Turn on all best warnings
ag-profile general -cflags -- -Wall -Wextra


# ------------
# Targets
# -----------

# Main target definition: Libraries in the srt package.

set haicrypt_libspec virtual

set TARGET_srt srt

if { [pget WITH_SRT_NAME] != "" } {
	set TARGET_srt $WITH_SRT_NAME
}

if { [pget WITH_HAICRYPT_NAME] != "" } {
	set TARGET_haicrypt $WITH_HAICRYPT_NAME
}

ag haicrypt -type library
ag $TARGET_srt -type library


if { $ENABLE_LOGGING } {
	ag $TARGET_srt -D ENABLE_LOGGING=1
	ag haicrypt -D ENABLE_LOGGING=1

	if {$ENABLE_HEAVY_LOGGING} {
		ag $TARGET_srt -D ENABLE_HEAVY_LOGGING=1
		ag haicrypt -D ENABLE_HEAVY_LOGGING=1
	}
}

if { $ENABLE_ENCRYPTION } {
	ag $TARGET_srt -D SRT_ENABLE_ENCRYPTION=1
}

if { [phas ENABLE_GETNAMEINFO] } {
	ag-profile {c c++} -D ENABLE_GETNAMEINFO=1
}

if { [pget ENABLE_PKTINFO] != 0 } {
	ag-profile {c c++} -D ENABLE_PKTINFO=1
}

# XXX
# As Silvercat doesn't support virtual libraries yet,
# we have to screw it up a little bit. This will be changed
# to normal library definition and processing once virtual
# library type is supported.

# Full support of virtual library requires that all sources
# of the dependent library be compiled according to the cflags
# defined in this very library, which need not be the same as
# the cflags defined in the depending library. Only linker flags
# are just integrated linker flags for both. Here it's not preserved.
# {
if { $haicrypt_libspec == "virtual" } {

	# Turn off automatic compiling of this library. Just stays for formality.
	# Set the language manually because without sources it won't be autodetected.
	ag haicrypt -runon demand -language c++

	# Make all next settings for haicrypt apply directly on srt
	set TARGET_haicrypt $TARGET_srt
} else {
	ag haicrypt -install lib -libspec $haicrypt_libspec
	ag $TARGET_srt -depends haicrypt
}
# }

ag $TARGET_srt -install lib -libspec $srt_libspec

# Ok, predefined, now specify the sources and public headers

# XXX on Windows add also srtcore/windows/win_time.cpp

# HaiCrypt

pinit USE_ENCLIB openssl

if {$ENABLE_ENCRYPTION} {

	# XXX Provide support for mbedtls and gnutls/nettle.
	set USE_ENCLIB openssl

	set maf_haicrypt [ag-maf haicrypt haicrypt filelist-$USE_ENCLIB.maf -s SOURCES -h {PUBLIC HEADERS} {PROTECTED HEADERS}]
	ag haicrypt -hidir srt
	#ag haicrypt -ldflags -- -lcrypto
	ag haicrypt -packages libcrypto

	if { $tcl_platform(os) == "Windows" } {
		ag-maf haicrypt common filelist_win32.maf -s SOURCES -h "PUBLIC HEADERS"
	}

	ag haicrypt -D {
	   HAICRYPT_USE_OPENSSL_EVP=1
	   HAICRYPT_USE_OPENSSL_AES
	}

	ag haicrypt -D USE_[string toupper $USE_ENCLIB]
}

# HaiSRT

set maf_srt [ag-maf $TARGET_srt srtcore filelist.maf -s SOURCES -h {PUBLIC HEADERS} {PROTECTED HEADERS}]
ag $TARGET_srt -hidir srt

if { [pget tcl_platform(os)] == "Linux" } {
	ag $TARGET_srt -ldflags -- -lpthread

	if {$ENABLE_ENCRYPTION && "shared" in [ag haicrypt ?libspec] } {
		# Required by linking a shared library against a shared library
		puts "NOTE: adding -fPIC due to linking libsrt.so against libcrypto. ADD AUTOMATIC RECOGNITION."
		ag haicrypt -cflags -- -fPIC
	}
}

# Instantiate and install config header
ag-instantiate srtcore/version.h.in include/version.h
ag $TARGET_srt -h //b:include/version.h
# Include path must be added to all targets, as they will include it intermediately
# (including apps)
ag-profile {c c++} -I //b:include

# XXX use the autogenerated pkg-config type here !!!
ag-instantiate scripts/srt.pc.in srt.pc
ag srt_pc -type custom -install lib/pkgconfig -s scripts/srt.pc.in -o srt.pc

# XXX Use MAF file to specify these details!

# Include directories (see Issue #72)
ag-profile general -I [pdip $agv::srcdir/% {
	srtcore
	haicrypt
	common
}]

# Definitions
ag-profile general -D {
   _GNU_SOURCE
}

set linux [expr {[pget tcl_platform(os)] == "Linux" }]

if { $linux } {
	ag-profile general -D LINUX
}

if { $SRT_BUILD_PROFILE } {
	ag-profile general -cflags -- -g -pg
	ag $TARGET_srt -ldflags -- -g -pg
}

# Now collect all source file names for tags

pset sources [pluniq [concat [ag $TARGET_srt ?sources] [ag haicrypt ?sources]]]

puts "SOURCES: $sources"

pset sourcedirs srtcore common haicrypt testing apps

# Extract all header files for tag generations

set all_headers [dict:sel $maf_srt -glob "* HEADERS"]
if {$ENABLE_ENCRYPTION} {
	lappend all_headers {*}[dict:sel $maf_haicrypt -glob "* HEADERS"]
}

#puts "HEADERS FOR CTAGS: $all_headers"

# Turn off compiling applications if static srt is unwanted
# because they will want to link against the static one.
if { "static" in $srt_libspec } {

	proc sprogram {name} {
		ag $name -type program -install bin -I apps common
	}

	proc srtapp {prg args} {
		set name $prg
		sprogram $name

		# Application main source file
		ag $name -s apps/$prg.cpp

		# Apps use ALL FILES from the support source category.
		ag-maf $name apps support.maf -s SOURCES

		# All apps are C++11
		ag $name -std c++11

		# Link against SRT
		ag $name -depends $::TARGET_srt/static
		if { [pget tcl_platform(os)] == "Linux" } {
			ag $name -ldflags -- -pthread
		}

		lappend ::appsources {*}[ag $name ?sources]
	}

	# Main SRT support applications	
	srtapp srt-live-transmit
	srtapp srt-file-transmit
	srtapp srt-multiplex

	proc testapp {prg args} {
		set name $prg
		sprogram $name

		# Add extra target settins if any
		ag $name {*}$args

		# All source files are taken exclusively from corresponding maf file.
		ag-maf $name testing $name.maf -s SOURCES
		lappend ::appsources {*}[ag $name ?sources]
		return $name
	}

	proc testapp-srt {prg args} {
		set name [testapp $prg {*}$args]

		ag $name -std c++11
		ag $name -depends $::TARGET_srt/static
		if { [pget tcl_platform(os)] == "Linux" } {
			ag $name -ldflags -- -pthread
		}
	}

	# Testprogram: special-case app, which consists of:
	# - apps/PROGRAM_NAME.cpp
	# - optional extra sources in common/ directory

	testapp utility-test
	testapp uriparser-test -D TEST -std c++11
	testapp-srt srt-test-live
	testapp-srt srt-test-file
	testapp-srt srt-test-relay
	ag srt-test-relay -D SRT_ENABLE_VERBOSE_LOCK -imgen target-name

	testapp-srt srt-test-multiplex

	proc exampleapp {prg args} {
		set name [file rootname $prg]

		sprogram $name

		ag $name -s examples/$prg {*}$args
		ag $name -depends $::TARGET_srt/static
		if { [pget tcl_platform(os)] == "Linux" } {
			ag $name -ldflags -- -pthread
		}
	}

	exampleapp sendfile.cpp apps/logsupport.cpp -std c++11
	exampleapp recvfile.cpp apps/logsupport.cpp -std c++11
	exampleapp testcapi-connect.c

	puts "APP SOURCES: $appsources"

	lappend sources {*}[pluniq $appsources]

} else {
	puts "NOTE: apps are disabled due to turning off static srt"
}

puts "ALL SOURCES: $sources"

ag tags -type custom -s $sources $all_headers -runon demand  -output //tags -clean none -flags noclean distclean

ag tags -command {
	cd $::agv::srcdir && ctags --c++-kinds=+px -R $sourcedirs && /usr/bin/ctags -a --c++-kinds=+px -R $sourcedirs
}


# vim:ft=tclmake
